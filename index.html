<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Official Library of Rathnir — §-formatted Books</title>
<style>
  :root{
    --bg: #1b1a16;
    --panel: #221f1b;
    --card: #2a2620;
    --muted: #c4bfae;
    --accent: #d8b36f; /* golden parchment hue */
    --highlight: #a1865b; /* bronze edge */
    --text: #f8f5e7;
    --glass: rgba(255,255,240,0.05);
    font-family: 'Cormorant Garamond', Georgia, serif;
  }

  html,body {
    height:100%;
    margin:0;
    background:radial-gradient(ellipse at top, #2b261f, var(--bg));
    color:var(--text);
    background-attachment: fixed;
  }

  .wrap {
    display:grid;
    grid-template-columns:320px 1fr;
    gap:18px;
    padding:20px;
    height:100vh;
    box-sizing:border-box;
  }

  .sidebar {
    background:var(--panel);
    border-radius:14px;
    padding:18px;
    box-shadow:0 6px 18px rgba(0,0,0,0.6), inset 0 0 30px rgba(255,245,230,0.03);
    border:1px solid rgba(255,245,230,0.08);
    overflow:auto;
  }

  .main {
    background:linear-gradient(180deg, rgba(255,255,240,0.05), rgba(255,255,220,0.02));
    border-radius:14px;
    padding:20px;
    box-shadow:0 6px 18px rgba(0,0,0,0.45), inset 0 0 30px rgba(255,245,230,0.03);
    border:1px solid rgba(255,245,230,0.08);
    overflow:auto;
  }

  h1 {
    margin:0 0 10px 0;
    font-size:22px;
    color:var(--accent);
    letter-spacing:0.5px;
    font-weight:600;
    text-transform:uppercase;
    border-bottom:1px solid rgba(216,179,111,0.4);
    padding-bottom:6px;
  }

  h2 {
    color:var(--accent);
  }

  .controls {
    display:flex;
    gap:8px;
    flex-wrap:wrap;
    margin-bottom:12px;
  }

  button,input[type="file"] {
    background:var(--glass);
    border:1px solid rgba(255,245,230,0.08);
    color:inherit;
    padding:8px 10px;
    border-radius:8px;
    cursor:pointer;
    transition:background 0.2s, border 0.2s;
    font-family:inherit;
  }
  button:hover,input[type="file"]:hover {
    background:rgba(255,245,230,0.08);
    border-color:rgba(216,179,111,0.5);
  }

  .book-list {
    margin-top:10px;
  }

  .book-item {
    padding:8px;
    border-radius:8px;
    margin-bottom:6px;
    cursor:pointer;
    background:transparent;
    border:1px solid rgba(255,255,240,0.05);
    transition:background 0.15s, transform 0.15s;
  }

  .book-item:hover {
    background:rgba(216,179,111,0.06);
    transform:translateX(2px);
  }

  .meta {
    color:var(--muted);
    font-size:13px;
    font-style:italic;
  }

  .viewer {
    background:linear-gradient(180deg,#1e1b16, #15130f);
    padding:18px;
    border-radius:10px;
    min-height:70vh;
    white-space:pre-wrap;
    overflow:auto;
    border:1px solid rgba(216,179,111,0.08);
    box-shadow:inset 0 0 30px rgba(255,245,230,0.02);
  }

  .book-title {
    font-size:22px;
    margin:0 0 6px 0;
    color:var(--accent);
  }

  .book-author {
    font-size:14px;
    color:var(--muted);
    margin:0 0 12px 0;
  }

  .search {
    width:100%;
    padding:8px;
    border-radius:8px;
    border:1px solid rgba(255,255,240,0.05);
    background:rgba(255,255,240,0.02);
    color:inherit;
    font-family:inherit;
  }

  .search:focus {
    outline:none;
    border-color:rgba(216,179,111,0.4);
    background:rgba(216,179,111,0.05);
  }

  .footer {
    margin-top:12px;
    color:var(--muted);
    font-size:13px;
  }

  .controls-row {
    display:flex;
    gap:8px;
    align-items:center;
  }

  .small {
    font-size:12px;
    padding:6px 8px;
  }

  /* Minecraft color classes */
  .mc-0{color:#000000}  .mc-1{color:#0000AA} .mc-2{color:#00AA00} .mc-3{color:#00AAAA}
  .mc-4{color:#AA0000}  .mc-5{color:#AA00AA} .mc-6{color:#FFAA00} .mc-7{color:#AAAAAA}
  .mc-8{color:#555555}  .mc-9{color:#5555FF} .mc-a{color:#55FF55} .mc-b{color:#55FFFF}
  .mc-c{color:#FF5555}  .mc-d{color:#FF55FF} .mc-e{color:#FFFF55} .mc-f{color:#FFFFFF}

  .mc-bold{font-weight:700}
  .mc-italic{font-style:italic}
  .mc-strike{text-decoration:line-through}
  .mc-underline{text-decoration:underline}
  .mc-reset{}

  .mc-obfuscated{font-family:monospace;letter-spacing:0.6px;display:inline-block}

  @media (max-width:900px){
    .wrap{grid-template-columns:1fr;}
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
<div class="wrap">
  <aside class="sidebar">
    <h1>Official Library of Rathnir</h1>
    <div class="controls">
      <input id="fileInput" type="file" accept=".txt"/>
      <button id="pasteBtn">Paste text</button>
      <button id="clearBtn">Clear</button>
    </div>

    <input id="search" class="search" placeholder="Search title / author / content..." />
    <div class="book-list" id="bookList"></div>
    <div class="footer">
      <div class="controls-row">
        <label class="small"><input id="obfToggle" type="checkbox" checked /> Animate §k (obfuscated)</label>
      </div>
      <div style="margin-top:8px">
        Save this file, open in browser, click <b>Load file</b> or <b>Paste text</b>.
      </div>
    </div>
  </aside>

  <main class="main">
    <div id="viewer" class="viewer">
      <div id="emptyState" style="opacity:0.7">
        <h2 style="margin-top:0">No tome selected</h2>
        <p>Import your cleaned file and click a book on the left to begin reading.  
        § codes such as <code>§c</code>, <code>§l</code>, <code>§o</code>, and <code>§k</code> will render faithfully.</p>
      </div>
      <div id="bookContent" style="display:none">
        <h2 id="title" class="book-title"></h2>
        <div id="author" class="book-author"></div>
        <div id="body" style="font-size:15px;line-height:1.55"></div>
      </div>
    </div>
  </main>
</div>

<script>
/* --- § formatting + library logic preserved --- */
const mcColorMap = {'0':'mc-0','1':'mc-1','2':'mc-2','3':'mc-3','4':'mc-4','5':'mc-5','6':'mc-6','7':'mc-7','8':'mc-8','9':'mc-9','a':'mc-a','b':'mc-b','c':'mc-c','d':'mc-d','e':'mc-e','f':'mc-f'};
const mcFormatMap = {'l':'mc-bold','o':'mc-italic','m':'mc-strike','n':'mc-underline','k':'mc-obfuscated','r':'mc-reset'};

let obfuscationEnabled = true;
let obfIntervals = new Set();

function clearObfIntervals(){for(const id of obfIntervals){clearInterval(id);}obfIntervals.clear();}

function makeObfuscatedSpan(text){
  const span=document.createElement('span');
  span.classList.add('mc-obfuscated');
  span.dataset.orig=text;
  span.textContent=obfTransform(text);
  const id=setInterval(()=>{
    if(!obfuscationEnabled){span.textContent=span.dataset.orig;return;}
    span.textContent=obfTransform(span.dataset.orig);
  },120);
  obfIntervals.add(id);
  return span;
}

function obfTransform(s){
  const chars='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()[]{}<>?/|';
  let out='';
  for(const ch of s){if(ch.trim()==='') out+=ch;else out+=chars[Math.floor(Math.random()*chars.length)];}
  return out;
}

function applyMinecraftFormatting(raw){
  const frag=document.createDocumentFragment();
  let i=0; let classes=new Set(); let buffer='';
  function pushTextChunk(t){
    if(!t) return;
    if(classes.has('mc-obfuscated')){
      const span=makeObfuscatedSpan(t);
      classes.forEach(cls=>{if(cls!=='mc-obfuscated') span.classList.add(cls);});
      frag.appendChild(span);
    }else{
      const span=document.createElement('span');
      classes.forEach(c=>span.classList.add(c));
      span.textContent=t;
      frag.appendChild(span);
    }
  }
  while(i<raw.length){
    const ch=raw[i];
    if(ch==='§'||ch==='\u00A7'){
      pushTextChunk(buffer); buffer='';
      const code=raw[i+1]?raw[i+1].toLowerCase():'';
      i+=2;
      if(mcColorMap[code]){for(const k in mcColorMap){classes.delete(mcColorMap[k]);}classes.add(mcColorMap[code]);}
      else if(mcFormatMap[code]){if(code==='r'){classes.clear();}else classes.add(mcFormatMap[code]);}
      else buffer+=ch;
      continue;
    } else {buffer+=ch; i++;}
  }
  pushTextChunk(buffer);
  return frag;
}

function parseBooksFromText(content){
  const rawEntries=content.split(/={3,}\s*\n/).map(s=>s.trim()).filter(Boolean);
  const books=[];
  for(const entry of rawEntries){
    const titleMatch=entry.match(/Title:\s*(.*)/i);
    const authorMatch=entry.match(/Author:\s*(.*)/i);
    const textMatch=entry.match(/Text:\s*([\s\S]*)/i);
    if(!titleMatch||!authorMatch||!textMatch) continue;
    const title=titleMatch[1].trim();
    const author=authorMatch[1].trim();
    let text=textMatch[1].trim();
    if(!title||!author||!text) continue;
    text=text.replace(/\r\n/g,'\n').replace(/\r/g,'\n');
    books.push({title,author,text});
  }
  return books;
}

const fileInput=document.getElementById('fileInput');
const bookList=document.getElementById('bookList');
const emptyState=document.getElementById('emptyState');
const bookContent=document.getElementById('bookContent');
const titleEl=document.getElementById('title');
const authorEl=document.getElementById('author');
const bodyEl=document.getElementById('body');
const searchEl=document.getElementById('search');
const pasteBtn=document.getElementById('pasteBtn');
const clearBtn=document.getElementById('clearBtn');
const obfToggle=document.getElementById('obfToggle');

let BOOKS=[];

fileInput.addEventListener('change',async(ev)=>{
  const file=ev.target.files[0];
  if(!file) return;
  const txt=await file.text();
  loadBooks(txt);
});

pasteBtn.addEventListener('click',async()=>{
  const pasted=prompt('Paste the contents of your cleaned book file here (or Cancel).');
  if(pasted) loadBooks(pasted);
});

clearBtn.addEventListener('click',()=>{
  BOOKS=[]; renderBookList(); showEmpty(); fileInput.value='';
});

obfToggle.addEventListener('change',()=>{
  obfuscationEnabled=obfToggle.checked;
  clearObfIntervals();
  const curTitle=titleEl.textContent;
  if(curTitle){
    const idx=BOOKS.findIndex(b=>b.title===curTitle&&b.author===authorEl.textContent);
    if(idx>=0) showBook(idx);
  }
});

function loadBooks(text){
  clearObfIntervals();
  BOOKS=parseBooksFromText(text);
  renderBookList();
  if(BOOKS.length>0) showBook(0); else showEmpty();
}

function renderBookList(filter=''){
  bookList.innerHTML='';
  const q=filter.trim().toLowerCase();
  BOOKS.forEach((b,i)=>{
    const combined=(b.title+' '+b.author+' '+b.text).toLowerCase();
    if(q&&!combined.includes(q)) return;
    const div=document.createElement('div');
    div.className='book-item';
    div.innerHTML=`<strong>${escapeHtml(b.title)}</strong><div class="meta">${escapeHtml(b.author)}</div>`;
    div.onclick=()=>showBook(i);
    bookList.appendChild(div);
  });
  if(bookList.children.length===0){
    bookList.innerHTML='<div style="opacity:0.6">No tomes found.</div>';
  }
}

searchEl.addEventListener('input',(e)=>{renderBookList(e.target.value);});

function showEmpty(){
  emptyState.style.display=''; bookContent.style.display='none';
  titleEl.textContent=''; authorEl.textContent=''; bodyEl.innerHTML='';
  clearObfIntervals();
}

function showBook(idx){
  clearObfIntervals();
  const b=BOOKS[idx];
  if(!b) return showEmpty();
  emptyState.style.display='none'; bookContent.style.display='';
  titleEl.textContent=b.title; authorEl.textContent=b.author;
  bodyEl.innerHTML='';
  const lines=b.text.split('\n');
  for(let li=0; li<lines.length; li++){
    const frag=applyMinecraftFormatting(lines[li]);
    bodyEl.appendChild(frag);
    if(li<lines.length-1) bodyEl.appendChild(document.createElement('br'));
  }
}

function escapeHtml(s){return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');}
</script>
<script>
  // Auto-load book_cleaned.txt once the DOM and library scripts are ready
  window.addEventListener('DOMContentLoaded', async () => {
    try {
      const response = await fetch('book_cleaned.txt');
      if (!response.ok) throw new Error('Failed to load book list');
      const text = await response.text();

      // Use the existing loadBooks function
      loadBooks(text);
    } catch (err) {
      console.error('Failed to auto-load book list:', err);
    }
  });
</script>
</body>
</html>
